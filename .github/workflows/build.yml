name: Build Raspberry Pi Image

on:
  workflow_dispatch:
    inputs:
      board:
        description: 'Target board'
        required: true
        default: 'raspberrypi5'
        type: choice
        options:
          - raspberrypi5
          - raspberrypizero2w-64
      init_system:
        description: 'Init system to build'
        required: true
        default: 'both'
        type: choice
        options:
          - runit
          - openrc
          - both
      buildroot_version:
        description: 'Buildroot version'
        required: false
        default: '2025.11'
        type: string
      build_debug:
        description: 'Build debug image with QEMU virt support'
        required: false
        default: 'false'
        type: boolean

env:
  BUILDROOT_VERSION: ${{ github.event.inputs.buildroot_version || '2025.11' }}
  TARGET_BOARD: ${{ github.event.inputs.board || 'raspberrypi5' }}
  BUILD_DEBUG: ${{ github.event.inputs.build_debug || 'false' }}
  BR2_DL_DIR: ${{ github.workspace }}/dl-cache
  BR2_CCACHE_DIR: ${{ github.workspace }}/ccache-cache

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - init_system: runit
            secret_name: BUILDROOT_EXTERNAL_RUNIT_TAR_BASE64
            build_suffix: runit
          - init_system: openrc
            secret_name: BUILDROOT_EXTERNAL_OPENRC_TAR_BASE64
            build_suffix: openrc
    runs-on: ubuntu-24.04
    timeout-minutes: 300  # 5 часов максимум
    outputs:
      target_board: ${{ env.TARGET_BOARD }}
    env:
      HAS_BUILDROOT_EXTERNAL: ${{ secrets[matrix.secret_name] != '' }}
      HAS_MEGA_CREDS: ${{ secrets.MEGA_USER != '' && secrets.MEGA_PASS != '' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check if build should run
        id: check_build
        run: |
          INIT_SYSTEM="${{ github.event.inputs.init_system }}"
          MATRIX_INIT="${{ matrix.init_system }}"
          
          # Use default 'both' if not set, empty, or null
          if [ -z "$INIT_SYSTEM" ] || [ "$INIT_SYSTEM" = "null" ] || [ "$INIT_SYSTEM" = "" ]; then
            INIT_SYSTEM="both"
          fi
          
          echo "Input init_system: '$INIT_SYSTEM'"
          echo "Matrix init_system: '$MATRIX_INIT'"
          
          # Determine if this matrix combination should build
          SHOULD_BUILD="false"
          if [ "$INIT_SYSTEM" = "both" ]; then
            SHOULD_BUILD="true"
            echo "✓ Building $MATRIX_INIT (init_system=both, building all)"
          elif [ "$INIT_SYSTEM" = "$MATRIX_INIT" ]; then
            SHOULD_BUILD="true"
            echo "✓ Building $MATRIX_INIT (init_system=$INIT_SYSTEM matches)"
          else
            SHOULD_BUILD="false"
            echo "⊘ Skipping $MATRIX_INIT (init_system=$INIT_SYSTEM, matrix=$MATRIX_INIT)"
          fi
          
          echo "should_build=$SHOULD_BUILD" >> $GITHUB_OUTPUT
          echo "Final decision: should_build=$SHOULD_BUILD"

      - name: Check Mega credentials
        if: steps.check_build.outputs.should_build == 'true'
        run: |
          if [ -z "${{ secrets.MEGA_USER }}" ]; then
            echo "::error::Mega credentials not configured!"
            echo "::error::MEGA_USER secret is required. Please configure it in repository settings."
            exit 1
          fi
          if [ -z "${{ secrets.MEGA_PASS }}" ]; then
            echo "::error::Mega password not configured!"
            echo "::error::MEGA_PASS secret is required. Please configure it in repository settings."
            exit 1
          fi
          echo "✓ Mega credentials configured"

      - name: Extract buildroot-external from secret
        if: ${{ steps.check_build.outputs.should_build == 'true' && env.HAS_BUILDROOT_EXTERNAL == 'true' }}
        env:
          BUILDROOT_EXTERNAL_TAR_BASE64: ${{ secrets[matrix.secret_name] }}
        run: |
          # Mask the secret in logs
          echo "::add-mask::$BUILDROOT_EXTERNAL_TAR_BASE64"
          
          echo "Extracting buildroot-external (${{ matrix.init_system }}) from secret..."
          
          # Decode and extract
          # Archive should contain buildroot-external/ directory structure
          # Extract to workspace root (not into buildroot-external/)
          # Support both .tar.gz and .tar.xz formats
          # Save to temp file to detect format, then extract
          echo "$BUILDROOT_EXTERNAL_TAR_BASE64" | base64 -d > /tmp/buildroot-external.tar.tmp
          FILE_TYPE=$(file -b /tmp/buildroot-external.tar.tmp)
          if echo "$FILE_TYPE" | grep -q "XZ compressed"; then
            # xz format
            tar -xJf /tmp/buildroot-external.tar.tmp
          else
            # gzip format (default)
            tar -xzf /tmp/buildroot-external.tar.tmp
          fi
          rm -f /tmp/buildroot-external.tar.tmp
          
          # Set execute permissions for host scripts only
          # Files in rootfs-overlay/ get permissions from file_permissions.txt via BR2_ROOTFS_DEVICE_TABLE
          chmod +x buildroot-external/scripts/*.sh 2>/dev/null || true
          chmod +x buildroot-external/board/*/post-build.sh 2>/dev/null || true
          chmod +x buildroot-external/board/*/post-image.sh 2>/dev/null || true

      - name: Free up disk space
        if: steps.check_build.outputs.should_build == 'true'
        run: |
          echo "=== Before cleanup ==="
          df -h
          
          # Remove unnecessary packages
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force
          
          echo "=== After cleanup ==="
          df -h

      - name: Install dependencies
        if: steps.check_build.outputs.should_build == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            libncurses5-dev \
            git \
            unzip \
            bc \
            cpio \
            rsync \
            wget \
            python3 \
            python3-pip \
            file \
            ccache \
            cryptsetup \
            parted \
            uuid-runtime \
            dosfstools \
            e2fsprogs

      - name: Cache Buildroot downloads
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/cache@v4
        with:
          path: ${{ env.BR2_DL_DIR }}
          # Use fixed key if buildroot-external is in secret (can't hash secret files)
          # Otherwise use hash of configs
          key: buildroot-dl-${{ env.BUILDROOT_VERSION }}-${{ env.HAS_BUILDROOT_EXTERNAL == 'true' && 'secret-external' || hashFiles('buildroot-external/configs/*') }}
          restore-keys: |
            buildroot-dl-${{ env.BUILDROOT_VERSION }}-
            buildroot-dl-

      - name: Cache ccache
        if: steps.check_build.outputs.should_build == 'true'
        uses: actions/cache@v4
        with:
          path: ${{ env.BR2_CCACHE_DIR }}
          # Include init_system to avoid cache conflicts between runit and openrc
          key: buildroot-ccache-${{ env.BUILDROOT_VERSION }}-${{ matrix.build_suffix }}-${{ github.sha }}
          restore-keys: |
            buildroot-ccache-${{ env.BUILDROOT_VERSION }}-${{ matrix.build_suffix }}-
            buildroot-ccache-${{ env.BUILDROOT_VERSION }}-
            buildroot-ccache-

      - name: Download and extract Buildroot
        if: steps.check_build.outputs.should_build == 'true'
        run: |
          wget -q "https://buildroot.org/downloads/buildroot-${BUILDROOT_VERSION}.tar.xz"
          tar -xf "buildroot-${BUILDROOT_VERSION}.tar.xz"
          mv "buildroot-${BUILDROOT_VERSION}" buildroot

      - name: Configure Buildroot
        if: steps.check_build.outputs.should_build == 'true'
        run: |
          cd buildroot
          
          # Set BR2_EXTERNAL
          export BR2_EXTERNAL="${{ github.workspace }}/buildroot-external"
          
          # Copy custom configs to buildroot
          if [ -d "${{ github.workspace }}/configs" ]; then
            cp ${{ github.workspace }}/configs/* configs/ 2>/dev/null || true
          fi
          
          # Determine which defconfig to use based on board
          if [ "${{ env.TARGET_BOARD }}" = "raspberrypizero2w-64" ]; then
            DEFCONFIG="raspberrypizero2w_64_luks_defconfig"
          else
            # Prefer custom defconfig if available
            if [ -f "configs/raspberrypi5_custom_luks_defconfig" ]; then
              DEFCONFIG="raspberrypi5_custom_luks_defconfig"
            else
              DEFCONFIG="raspberrypi5_luks_defconfig"
            fi
          fi
          echo "Using defconfig: $DEFCONFIG"
          
          # Load defconfig
          make $DEFCONFIG
          
          # Explicitly disable encryption
          echo "BR2_LUKS_ENCRYPT=n" >> .config
          
          # Add virtio debug fragment for QEMU virt machine support (if debug build)
          if [ "${{ env.BUILD_DEBUG }}" = "true" ] && [ "${{ env.TARGET_BOARD }}" = "raspberrypizero2w-64" ]; then
            echo "Adding virtio debug fragment for QEMU virt machine..."
            # Use Buildroot variable format for consistency with defconfig
            VIRTIO_FRAGMENT="\$(BR2_EXTERNAL_LUKS_PI_PATH)/board/raspberrypizero2w-64/linux-virtio-debug.fragment"
            VIRTIO_FRAGMENT_ABS="${BR2_EXTERNAL}/board/raspberrypizero2w-64/linux-virtio-debug.fragment"
            
            if [ -f "$VIRTIO_FRAGMENT_ABS" ]; then
              # Get current fragment files (may contain Buildroot variables)
              CURRENT_FRAGS=$(grep "^BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES=" .config | cut -d'"' -f2 || echo "")
              if [ -n "$CURRENT_FRAGS" ]; then
                # Append virtio fragment to existing fragments
                sed -i "s|^BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES=.*|BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES=\"${CURRENT_FRAGS} ${VIRTIO_FRAGMENT}\"|" .config
              else
                # Set if not present
                echo "BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES=\"${VIRTIO_FRAGMENT}\"" >> .config
              fi
              echo "Virtio debug fragment added: $VIRTIO_FRAGMENT"
            else
              echo "Warning: Virtio debug fragment not found: $VIRTIO_FRAGMENT_ABS"
            fi
          fi
          
          # Set cache directories
          echo "BR2_DL_DIR=\"${BR2_DL_DIR}\"" >> .config
          echo "BR2_CCACHE=y" >> .config
          echo "BR2_CCACHE_DIR=\"${BR2_CCACHE_DIR}\"" >> .config
          
          # Update config
          make olddefconfig

      - name: Build image
        if: steps.check_build.outputs.should_build == 'true'
        run: |
          cd buildroot
          export BR2_EXTERNAL="${{ github.workspace }}/buildroot-external"
          
          # Build with parallel jobs
          make -j$(nproc)

      - name: Prepare artifacts
        if: steps.check_build.outputs.should_build == 'true'
        run: |
          mkdir -p artifacts
          cd buildroot/output/images
          
          # Copy images with debug suffix if debug build
          if [ -f "sdcard.img" ]; then
            xz -T0 -9 sdcard.img
            if [ "${{ env.BUILD_DEBUG }}" = "true" ]; then
              cp sdcard.img.xz ${{ github.workspace }}/artifacts/sdcard-debug-virtio.img.xz
            else
              cp sdcard.img.xz ${{ github.workspace }}/artifacts/sdcard.img.xz
            fi
          fi
          
          # Create checksums
          cd ${{ github.workspace }}/artifacts
          sha256sum *.img.xz > SHA256SUMS.txt 2>/dev/null || true

      - name: Upload to Mega
        if: steps.check_build.outputs.should_build == 'true'
        id: upload_mega
        continue-on-error: true
        env:
          MEGA_USER: ${{ secrets.MEGA_USER }}
          MEGA_PASS: ${{ secrets.MEGA_PASS }}
          MEGA_FOLDER_ID: ${{ secrets.MEGA_FOLDER_ID }}
        run: |
          set -e
          
          # Install rclone
          curl -sSL https://rclone.org/install.sh | sudo bash
          
          # Configure rclone for Mega
          mkdir -p ~/.config/rclone
          cat > ~/.config/rclone/rclone.conf << EOF
          [mega]
          type = mega
          user = ${MEGA_USER}
          pass = ${MEGA_PASS}
          EOF
          
          # Create folder structure: builds/<board>-<init_system>-<date>-<run_id>/
          BUILD_FOLDER="builds/${{ env.TARGET_BOARD }}-${{ matrix.build_suffix }}-$(date +%Y-%m-%d)-${{ github.run_id }}"
          FULL_PATH="${MEGA_FOLDER_ID:-/}${BUILD_FOLDER}"
          
          # Create remote directory if not exists
          rclone mkdir "mega:${FULL_PATH}/images/" || true
          
          UPLOAD_FAILED=0
          
          # Upload image(s)
          if [ -f "artifacts/sdcard.img.xz" ]; then
            echo "Uploading image to Mega..."
            rclone copy artifacts/sdcard.img.xz "mega:${FULL_PATH}/images/" --progress || UPLOAD_FAILED=1
          fi
          if [ -f "artifacts/sdcard-debug-virtio.img.xz" ]; then
            echo "Uploading debug image to Mega..."
            rclone copy artifacts/sdcard-debug-virtio.img.xz "mega:${FULL_PATH}/images/" --progress || UPLOAD_FAILED=1
          fi
          if [ -f "artifacts/SHA256SUMS.txt" ]; then
            rclone copy artifacts/SHA256SUMS.txt "mega:${FULL_PATH}/images/" --progress || UPLOAD_FAILED=1
          fi
          
          # Create manifest
          cat > /tmp/build-info.txt << EOF
          Build Information
          =================
          Repository: ${{ github.repository }}
          Run ID: ${{ github.run_id }}
          Commit: ${{ github.sha }}
          Branch: ${{ github.ref_name }}
          Date: $(date -Iseconds)
          Buildroot: ${BUILDROOT_VERSION}
          Encrypted: false
          Debug (QEMU virt): ${{ env.BUILD_DEBUG }}
          
          Files:
          $(ls -la artifacts/ 2>/dev/null || echo "No artifacts")
          EOF
          rclone copy /tmp/build-info.txt "mega:${FULL_PATH}/" --progress || UPLOAD_FAILED=1
          
          if [ $UPLOAD_FAILED -eq 0 ]; then
            echo "Uploaded to Mega: ${FULL_PATH}"
            echo "mega_upload_success=true" >> $GITHUB_OUTPUT
          else
            echo "::error::Failed to upload to Mega"
            echo "mega_upload_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Upload artifacts to GitHub (fallback)
        if: steps.upload_mega.outcome == 'failure' || env.HAS_MEGA_CREDS == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ format('{0}-{1}{2}-images', env.TARGET_BOARD, matrix.build_suffix, env.BUILD_DEBUG == 'true' && '-debug-virtio' || '') }}
          path: artifacts/
          retention-days: 7
          if-no-files-found: error

  # Optional: Create release on tag
  release:
    needs: build
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-24.04
    permissions:
      contents: write

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.target_board }}-images
          path: release/

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            release/*.img.xz
            release/SHA256SUMS.txt
          body: |
            ## Raspberry Pi Image (${{ needs.build.outputs.target_board }})
            
            ### Files
            - `sdcard.img.xz` - SD card image
            
            ### Usage
            ```bash
            # Extract and burn
            xz -d sdcard.img.xz
            sudo dd if=sdcard.img of=/dev/sdX bs=4M status=progress
            ```
          draft: false
          prerelease: false
