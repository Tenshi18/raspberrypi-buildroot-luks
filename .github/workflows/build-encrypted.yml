name: Build Raspberry Pi LUKS Image

on:
  workflow_dispatch:
    inputs:
      board:
        description: 'Target board'
        required: true
        default: 'raspberrypi5'
        type: choice
        options:
          - raspberrypi5
          - raspberrypizero2w-64
      encrypt:
        description: 'Enable LUKS encryption'
        required: true
        default: true
        type: boolean
      keep_unencrypted:
        description: 'Keep unencrypted image'
        required: false
        default: false
        type: boolean
      buildroot_version:
        description: 'Buildroot version'
        required: false
        default: '2025.11'
        type: string
      build_debug:
        description: 'Build debug image with QEMU virt support'
        required: false
        default: 'false'
        type: boolean

env:
  BUILDROOT_VERSION: ${{ github.event.inputs.buildroot_version || '2025.11' }}
  TARGET_BOARD: ${{ github.event.inputs.board || 'raspberrypi5' }}
  BUILD_DEBUG: ${{ github.event.inputs.build_debug || 'false' }}
  BR2_DL_DIR: ${{ github.workspace }}/dl-cache
  BR2_CCACHE_DIR: ${{ github.workspace }}/ccache-cache

jobs:
  build:
    runs-on: ubuntu-24.04
    timeout-minutes: 300  # 5 часов максимум
    outputs:
      target_board: ${{ env.TARGET_BOARD }}
    env:
      HAS_BUILDROOT_EXTERNAL: ${{ secrets.BUILDROOT_EXTERNAL_TAR_BASE64 != '' }}
      HAS_BOARD_OVERLAY: ${{ secrets.BOARD_OVERLAY_TAR_BASE64 != '' }}
      HAS_LUKS_KEYFILE: ${{ secrets.LUKS_KEYFILE_BASE64 != '' }}
      HAS_MEGA_CREDS: ${{ secrets.MEGA_USER != '' && secrets.MEGA_PASS != '' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check Mega credentials
        run: |
          if [ -z "${{ secrets.MEGA_USER }}" ]; then
            echo "::error::Mega credentials not configured!"
            echo "::error::MEGA_USER secret is required. Please configure it in repository settings."
            exit 1
          fi
          if [ -z "${{ secrets.MEGA_PASS }}" ]; then
            echo "::error::Mega password not configured!"
            echo "::error::MEGA_PASS secret is required. Please configure it in repository settings."
            exit 1
          fi
          echo "✓ Mega credentials configured"

      - name: Extract buildroot-external from secret
        if: ${{ env.HAS_BUILDROOT_EXTERNAL == 'true' }}
        env:
          BUILDROOT_EXTERNAL_TAR_BASE64: ${{ secrets.BUILDROOT_EXTERNAL_TAR_BASE64 }}
        run: |
          # Mask the secret in logs
          echo "::add-mask::$BUILDROOT_EXTERNAL_TAR_BASE64"
          
          echo "Extracting buildroot-external from secret..."
          
          # Decode and extract
          # Archive should contain buildroot-external/ directory structure
          # Extract to workspace root (not into buildroot-external/)
          echo "$BUILDROOT_EXTERNAL_TAR_BASE64" | base64 -d | tar -xz
          
          # Set execute permissions for host scripts only
          # Files in rootfs-overlay/ get permissions from file_permissions.txt via BR2_ROOTFS_DEVICE_TABLE
          chmod +x buildroot-external/scripts/*.sh 2>/dev/null || true
          chmod +x buildroot-external/board/*/post-build.sh 2>/dev/null || true
          chmod +x buildroot-external/board/*/post-image.sh 2>/dev/null || true

      - name: Extract secret board overlay (legacy, if buildroot-external not in secret)
        if: ${{ env.HAS_BOARD_OVERLAY == 'true' && env.HAS_BUILDROOT_EXTERNAL == 'false' }}
        env:
          BOARD_OVERLAY_TAR_BASE64: ${{ secrets.BOARD_OVERLAY_TAR_BASE64 }}
        run: |
          # Mask the secret in logs
          echo "::add-mask::$BOARD_OVERLAY_TAR_BASE64"
          
          BOARD_DIR="buildroot-external/board/${{ env.TARGET_BOARD }}"
          echo "Extracting secret board overlay to $BOARD_DIR..."
          
          # Create directory if it doesn't exist
          mkdir -p "$BOARD_DIR"
          
          # Decode and extract
          # Archive should contain files without parent directory (created with -C board-dir .)
          echo "$BOARD_OVERLAY_TAR_BASE64" | base64 -d | tar -xz -C "$BOARD_DIR/"
          
          # Set execute permissions for host scripts only
          # Files in rootfs-overlay/ get permissions from file_permissions.txt via BR2_ROOTFS_DEVICE_TABLE
          chmod +x "$BOARD_DIR"/post-build.sh 2>/dev/null || true
          chmod +x "$BOARD_DIR"/post-image.sh 2>/dev/null || true

      - name: Free up disk space
        run: |
          echo "=== Before cleanup ==="
          df -h
          
          # Remove unnecessary packages
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force
          
          echo "=== After cleanup ==="
          df -h

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            libncurses5-dev \
            git \
            unzip \
            bc \
            cpio \
            rsync \
            wget \
            python3 \
            python3-pip \
            file \
            ccache \
            cryptsetup \
            parted \
            uuid-runtime \
            dosfstools \
            e2fsprogs

      - name: Cache Buildroot downloads
        uses: actions/cache@v4
        with:
          path: ${{ env.BR2_DL_DIR }}
          # Use fixed key if buildroot-external is in secret (can't hash secret files)
          # Otherwise use hash of configs
          key: buildroot-dl-${{ env.BUILDROOT_VERSION }}-${{ env.HAS_BUILDROOT_EXTERNAL == 'true' && 'secret-external' || hashFiles('buildroot-external/configs/*') }}
          restore-keys: |
            buildroot-dl-${{ env.BUILDROOT_VERSION }}-
            buildroot-dl-

      - name: Cache ccache
        uses: actions/cache@v4
        with:
          path: ${{ env.BR2_CCACHE_DIR }}
          key: buildroot-ccache-${{ env.BUILDROOT_VERSION }}-${{ github.sha }}
          restore-keys: |
            buildroot-ccache-${{ env.BUILDROOT_VERSION }}-
            buildroot-ccache-

      - name: Download and extract Buildroot
        run: |
          wget -q "https://buildroot.org/downloads/buildroot-${BUILDROOT_VERSION}.tar.xz"
          tar -xf "buildroot-${BUILDROOT_VERSION}.tar.xz"
          mv "buildroot-${BUILDROOT_VERSION}" buildroot

      - name: Configure Buildroot
        run: |
          cd buildroot
          
          # Set BR2_EXTERNAL
          export BR2_EXTERNAL="${{ github.workspace }}/buildroot-external"
          
          # Copy custom configs to buildroot
          if [ -d "${{ github.workspace }}/configs" ]; then
            cp ${{ github.workspace }}/configs/* configs/ 2>/dev/null || true
          fi
          
          # Determine which defconfig to use based on board
          if [ "${{ env.TARGET_BOARD }}" = "raspberrypizero2w-64" ]; then
            DEFCONFIG="raspberrypizero2w_64_luks_defconfig"
          else
            # Prefer custom defconfig if available
            if [ -f "configs/raspberrypi5_custom_luks_defconfig" ]; then
              DEFCONFIG="raspberrypi5_custom_luks_defconfig"
            else
              DEFCONFIG="raspberrypi5_luks_defconfig"
            fi
          fi
          echo "Using defconfig: $DEFCONFIG"
          
          # Load defconfig
          make $DEFCONFIG
          
          # Configure encryption based on input
          if [ "${{ github.event.inputs.encrypt }}" = "false" ]; then
            echo "BR2_LUKS_ENCRYPT=n" >> .config
          else
            echo "BR2_LUKS_ENCRYPT=y" >> .config
          fi
          
          if [ "${{ github.event.inputs.keep_unencrypted }}" = "true" ]; then
            echo "BR2_LUKS_KEEP_UNENCRYPTED=y" >> .config
          fi
          
          # Add virtio debug fragment for QEMU virt machine support (if debug build)
          if [ "${{ env.BUILD_DEBUG }}" = "true" ] && [ "${{ env.TARGET_BOARD }}" = "raspberrypizero2w-64" ]; then
            echo "Adding virtio debug fragment for QEMU virt machine..."
            # Use Buildroot variable format for consistency with defconfig
            VIRTIO_FRAGMENT="\$(BR2_EXTERNAL_LUKS_PI_PATH)/board/raspberrypizero2w-64/linux-virtio-debug.fragment"
            VIRTIO_FRAGMENT_ABS="${BR2_EXTERNAL}/board/raspberrypizero2w-64/linux-virtio-debug.fragment"
            
            if [ -f "$VIRTIO_FRAGMENT_ABS" ]; then
              # Get current fragment files (may contain Buildroot variables)
              CURRENT_FRAGS=$(grep "^BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES=" .config | cut -d'"' -f2 || echo "")
              if [ -n "$CURRENT_FRAGS" ]; then
                # Append virtio fragment to existing fragments
                sed -i "s|^BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES=.*|BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES=\"${CURRENT_FRAGS} ${VIRTIO_FRAGMENT}\"|" .config
              else
                # Set if not present
                echo "BR2_LINUX_KERNEL_CONFIG_FRAGMENT_FILES=\"${VIRTIO_FRAGMENT}\"" >> .config
              fi
              echo "Virtio debug fragment added: $VIRTIO_FRAGMENT"
            else
              echo "Warning: Virtio debug fragment not found: $VIRTIO_FRAGMENT_ABS"
            fi
          fi
          
          # Set cache directories
          echo "BR2_DL_DIR=\"${BR2_DL_DIR}\"" >> .config
          echo "BR2_CCACHE=y" >> .config
          echo "BR2_CCACHE_DIR=\"${BR2_CCACHE_DIR}\"" >> .config
          
          # Update config
          make olddefconfig

      - name: Build image
        run: |
          cd buildroot
          export BR2_EXTERNAL="${{ github.workspace }}/buildroot-external"
          
          # Build with parallel jobs
          make -j$(nproc)

      - name: Prepare keyfile from secret (if provided)
        if: ${{ github.event.inputs.encrypt != 'false' && env.HAS_LUKS_KEYFILE == 'true' }}
        env:
          LUKS_KEYFILE_BASE64: ${{ secrets.LUKS_KEYFILE_BASE64 }}
        run: |
          # Mask the base64-encoded secret in logs
          echo "::add-mask::$LUKS_KEYFILE_BASE64"
          
          mkdir -p buildroot/output/images/keys
          echo "$LUKS_KEYFILE_BASE64" | base64 -d > buildroot/output/images/keys/secret.lek
          chmod 600 buildroot/output/images/keys/secret.lek
          
          # Mark that we used a secret (don't upload keyfile later)
          touch buildroot/output/images/keys/.from_secret
          echo "Using keyfile from GitHub Secret"

      - name: Encrypt image (if enabled)
        if: ${{ github.event.inputs.encrypt != 'false' }}
        env:
          LUKS_KEYFILE_BASE64: ${{ secrets.LUKS_KEYFILE_BASE64 }}
          LUKS_PASSPHRASE: ${{ secrets.LUKS_PASSPHRASE }}
        run: |
          cd buildroot/output/images
          
          # Check if encryption was done by post-image script
          if [ -f "encryption-info.txt" ]; then
            echo "Image already encrypted by post-image script"
            cat encryption-info.txt
          else
            echo "Running manual encryption..."
            
            # Determine key source
            KEYFILE_ARG=""
            if [ -f "./keys/secret.lek" ]; then
              # Use keyfile from secret
              KEYFILE_ARG="--keyfile ./keys/secret.lek"
              echo "Using keyfile from GitHub Secret"
            elif [ -n "$LUKS_PASSPHRASE" ]; then
              # Mask derived values in logs
              PASS_HASH=$(echo -n "$LUKS_PASSPHRASE" | sha256sum | cut -d' ' -f1)
              echo "::add-mask::$PASS_HASH"
              
              # Use passphrase from secret (create keyfile from it)
              mkdir -p ./keys
              echo -n "$PASS_HASH" | xxd -r -p > ./keys/passphrase.lek
              dd if=/dev/urandom bs=1 count=224 >> ./keys/passphrase.lek 2>/dev/null
              KEYFILE_ARG="--keyfile ./keys/passphrase.lek"
              
              # Mark that we used a secret
              touch ./keys/.from_secret
              echo "Using passphrase-derived keyfile from GitHub Secret"
            else
              # Generate unique keyfile
              KEYFILE_ARG="--keydir ./keys"
              echo "Generating unique keyfile"
            fi
            
            sudo ${{ github.workspace }}/pre-burn-encrypt.sh \
              $KEYFILE_ARG \
              --crypto aes \
              sdcard.img \
              sdcard-encrypted.img
          fi

      - name: Prepare artifacts
        run: |
          mkdir -p artifacts artifacts-keys
          cd buildroot/output/images
          
          # Copy images (NOT keys) with debug suffix if debug build
          if [ -f "sdcard-encrypted.img" ]; then
            xz -T0 -9 sdcard-encrypted.img
            if [ "${{ env.BUILD_DEBUG }}" = "true" ]; then
              cp sdcard-encrypted.img.xz ${{ github.workspace }}/artifacts/sdcard-encrypted-debug-virtio.img.xz
            else
              cp sdcard-encrypted.img.xz ${{ github.workspace }}/artifacts/
            fi
          fi
          
          if [ -f "sdcard.img" ]; then
            xz -T0 -9 sdcard.img
            if [ "${{ env.BUILD_DEBUG }}" = "true" ]; then
              cp sdcard.img.xz ${{ github.workspace }}/artifacts/sdcard-debug-virtio.img.xz
            else
              cp sdcard.img.xz ${{ github.workspace }}/artifacts/
            fi
          fi
          
          # Copy encryption info (without sensitive data)
          if [ -f "encryption-info.txt" ]; then
            cp encryption-info.txt ${{ github.workspace }}/artifacts/
          fi
          
          # Handle keyfiles separately
          if [ -d "keys" ]; then
            if [ -f "keys/.from_secret" ]; then
              # Keyfile came from secret - don't upload it
              echo "Keyfile from GitHub Secret - not uploading to artifacts"
              echo "SKIP_KEYFILE_UPLOAD=true" >> $GITHUB_ENV
            else
              # Auto-generated keyfile - upload to separate artifact
              cp -r keys ${{ github.workspace }}/artifacts-keys/
              echo "Auto-generated keyfile will be uploaded"
            fi
          fi
          
          # Create checksums
          cd ${{ github.workspace }}/artifacts
          sha256sum *.img.xz > SHA256SUMS.txt 2>/dev/null || true

      - name: Upload to Mega
        id: upload_mega
        continue-on-error: true
        env:
          MEGA_USER: ${{ secrets.MEGA_USER }}
          MEGA_PASS: ${{ secrets.MEGA_PASS }}
          MEGA_FOLDER_ID: ${{ secrets.MEGA_FOLDER_ID }}
        run: |
          set -e
          
          # Install rclone
          curl -sSL https://rclone.org/install.sh | sudo bash
          
          # Configure rclone for Mega
          mkdir -p ~/.config/rclone
          cat > ~/.config/rclone/rclone.conf << EOF
          [mega]
          type = mega
          user = ${MEGA_USER}
          pass = ${MEGA_PASS}
          EOF
          
          # Create folder structure: builds/<board>-<date>-<run_id>/
          BUILD_FOLDER="builds/${{ env.TARGET_BOARD }}-$(date +%Y-%m-%d)-${{ github.run_id }}"
          FULL_PATH="${MEGA_FOLDER_ID:-/}${BUILD_FOLDER}"
          
          # Create remote directories if not exist
          rclone mkdir "mega:${FULL_PATH}/images/" || true
          rclone mkdir "mega:${FULL_PATH}/keys/" || true
          
          UPLOAD_FAILED=0
          
          # Upload encrypted image(s)
          if [ -f "artifacts/sdcard-encrypted.img.xz" ]; then
            echo "Uploading encrypted image to Mega..."
            rclone copy artifacts/sdcard-encrypted.img.xz "mega:${FULL_PATH}/images/" --progress || UPLOAD_FAILED=1
          fi
          if [ -f "artifacts/sdcard-encrypted-debug-virtio.img.xz" ]; then
            echo "Uploading debug encrypted image to Mega..."
            rclone copy artifacts/sdcard-encrypted-debug-virtio.img.xz "mega:${FULL_PATH}/images/" --progress || UPLOAD_FAILED=1
          fi
          if [ -f "artifacts/sdcard-debug-virtio.img.xz" ]; then
            echo "Uploading debug unencrypted image to Mega..."
            rclone copy artifacts/sdcard-debug-virtio.img.xz "mega:${FULL_PATH}/images/" --progress || UPLOAD_FAILED=1
          fi
          if [ -f "artifacts/SHA256SUMS.txt" ]; then
            rclone copy artifacts/SHA256SUMS.txt "mega:${FULL_PATH}/images/" --progress || UPLOAD_FAILED=1
          fi
          
          # Upload keyfiles (only if auto-generated)
          if [ "$SKIP_KEYFILE_UPLOAD" != "true" ] && [ -d "artifacts-keys/keys" ]; then
            echo "Uploading keyfiles to Mega..."
            rclone copy artifacts-keys/keys/ "mega:${FULL_PATH}/keys/" --progress || UPLOAD_FAILED=1
          fi
          
          # Upload encryption info
          if [ -f "artifacts/encryption-info.txt" ]; then
            rclone copy artifacts/encryption-info.txt "mega:${FULL_PATH}/" --progress || UPLOAD_FAILED=1
          fi
          
          # Create manifest
          cat > /tmp/build-info.txt << EOF
          Build Information
          =================
          Repository: ${{ github.repository }}
          Run ID: ${{ github.run_id }}
          Commit: ${{ github.sha }}
          Branch: ${{ github.ref_name }}
          Date: $(date -Iseconds)
          Buildroot: ${BUILDROOT_VERSION}
          Encrypted: ${{ github.event.inputs.encrypt }}
          Debug (QEMU virt): ${{ env.BUILD_DEBUG }}
          
          Files:
          $(ls -la artifacts/ 2>/dev/null || echo "No artifacts")
          EOF
          rclone copy /tmp/build-info.txt "mega:${FULL_PATH}/" --progress || UPLOAD_FAILED=1
          
          if [ $UPLOAD_FAILED -eq 0 ]; then
            echo "Uploaded to Mega: ${FULL_PATH}"
            echo "mega_upload_success=true" >> $GITHUB_OUTPUT
          else
            echo "::error::Failed to upload to Mega"
            echo "mega_upload_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Upload artifacts to GitHub (fallback)
        if: steps.upload_mega.outcome == 'failure' || env.HAS_MEGA_CREDS == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ format('{0}{1}-luks-images', env.TARGET_BOARD, env.BUILD_DEBUG == 'true' && '-debug-virtio' || '') }}
          path: artifacts/
          retention-days: 7
          if-no-files-found: error

      - name: Upload keyfiles to GitHub (fallback)
        if: steps.upload_mega.outcome == 'failure' || env.HAS_MEGA_CREDS == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.TARGET_BOARD }}-luks-keys
          path: artifacts-keys/
          retention-days: 7
          if-no-files-found: warn

  # Optional: Create release on tag
  release:
    needs: build
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-24.04
    permissions:
      contents: write

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.target_board }}-luks-images
          path: release/

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          fail_on_unmatched_files: false
          files: |
            release/*.img.xz
            release/SHA256SUMS.txt
            release/encryption-info.txt
          body: |
            ## Raspberry Pi LUKS Encrypted Image (${{ needs.build.outputs.target_board }})
            
            ### Files
            - `sdcard-encrypted.img.xz` - Encrypted SD card image
            - `sdcard.img.xz` - Unencrypted image (if enabled)
            
            ### Usage
            ```bash
            # Extract and burn
            xz -d sdcard-encrypted.img.xz
            sudo dd if=sdcard-encrypted.img of=/dev/sdX bs=4M status=progress
            ```
            
            **Important:** Download keyfiles from workflow artifacts (expires in 7 days)
          draft: false
          prerelease: false
